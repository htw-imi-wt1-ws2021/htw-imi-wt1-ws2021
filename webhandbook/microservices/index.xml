<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Microservices on Documentation for our Projects and Web Handbook</title><link>/webhandbook/microservices/</link><description>Recent content in Microservices on Documentation for our Projects and Web Handbook</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><atom:link href="/webhandbook/microservices/index.xml" rel="self" type="application/rss+xml"/><item><title>1. Einleitung</title><link>/webhandbook/microservices/_1_einleitung/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/webhandbook/microservices/_1_einleitung/</guid><description>“So there is a point at which you have too many developers trying to change the movie object or whatever, the customer object. Everyone wants to change that object for some reason and they can’t all change it at once; so you get these collisions in the system.“ Viele Applikationen sind monolithisch geschrieben. Sämtliche Businesslogiken laufen über einem System ab. Damit Geschäfte profitabel laufen, müssen sie ständig neue Features entwickeln, den “Monolith-App” testen, bauen und dann in die Produktion ausliefern.</description></item><item><title>Evaluation</title><link>/webhandbook/microservices/_6_evaluation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/webhandbook/microservices/_6_evaluation/</guid><description>Letzten Endes entscheidet das Team, ob sie für ihren System einen Monolithen oder eine Microservice-Architektur entwickeln. Beide Architekturen sind mit Vor- und Nachteilen verbunden und diejenigen Entwickler müssen vorsichtig überlegen, ob sie für das jetzige bestehende System oder für ein neu konstruiertes System eine Microservice-Architektur entworfen wolleb. Für Entwickler ist es möglich neue Features zu implementieren, Tests zu beheben, Fehler effizienter zu isolieren, ohne dabei das gesamte System und die Nutzererfahrung zu beeinträchtigen, jedenfalls treten einige Konsequenzen auf.</description></item><item><title>Literaturverzeichnus</title><link>/webhandbook/microservices/_7_literaturverzeichnis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/webhandbook/microservices/_7_literaturverzeichnis/</guid><description> InfoQ,“ 2014. [Online]. Available: https://web.archive.org/web/20200106141538/https://www.infoq.com/interviews/adrian-cockcroft-microservices-devops/. [Zugriff am 15. 01. 2022] S. Newmann, Building Microservices, O&amp;rsquo;Reilly Media, Inc., 2015. M. Villamizar, O. Garcés, H. Castro, M. Verano, L. Salamanca, R. Casallas und S. Gil, „Evaluating the monolithic and the microservice architecture pattern to deploy web applications in the cloud,“ IEEE, 2015. E. Evans, Domain-driven Design, Addison-Wesley, 2003.</description></item><item><title>Microservices</title><link>/webhandbook/microservices/_3_microservices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/webhandbook/microservices/_3_microservices/</guid><description>Bedeutung Microservices sind kleine Einheiten eines Systems, die eine Menge von Funktionen und Eigenschaften einer Entität besitzen. Sie folgen dem „Single-Responsibilty-Principle“ und übernehmen eine Funktionalität des Systems. Sie sind eingegrenzt, nur nach ihren zugewiesenen Aufgaben, die von den Entwicklern selbst definiert sind, auszuführen. [2] Jeder Microservice bekommt ihre eigene Programmiersprache und Datenbanktyp als Umgebung. Alle Services laufen in ihrer eigenen Instanz.
Zweck von Microservices Sinn und Zweck von Microservices ist es ein flexibles System zu entwickeln, um Systemausfälle zu verhindern, neue Features auszuliefern, ohne dabei anderen Funktionen aus anderen Quellen einzubeziehen.</description></item><item><title>Monolithische Applikationen</title><link>/webhandbook/microservices/_2_monolithische_applikationen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/webhandbook/microservices/_2_monolithische_applikationen/</guid><description>Beschreibung und Aufbau Monolithen sind in einer großen Codebasis geschrieben. Sämtliche Web-Prozesse des Business laufen über diesem Repository ab. Die Datenabfragen- und erstellungen erfolgen über eine Datenbankinstanz, die eine Menge von Tabellen hat. Der einzige Monolith ist für das Entgegennehmen der Anfragen von Browser- und mobilen Nativanwendungen zuständig.
Problem einer monolithischen Applikation Der Code wächst, je mehr Features ausgeliefert werden. Das Warten und Ändern des immer komplexer werdenden Codes ist erschwert, da selbst bei strengen Coderegeln immer wieder Eigenheiten und unterschiedliche Wissensstände der Entwickler zu komplexem und teilweise zu einarbeitungsintensivem Code führt.</description></item><item><title>Serviceorientierte Modellierung</title><link>/webhandbook/microservices/_4_serviceorientierte_modellierung/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/webhandbook/microservices/_4_serviceorientierte_modellierung/</guid><description>Kernaspekte einer Microservice-Architektur Zwei Hauptmerkmale für eine Microservice-Architektur sind einerseits unabhängige Verknüpfungen und andererseits starke Zusammenhänge zwischen den Services. Ändert sich ein Service, ohne andere Komponenten zu ändern und zu benötigen, so ist dieser Dienst unabhängig. Eigenschaften und Methoden, die zusammenhängend sind, gehören in einem Modul.
Um Probleme genau einzugrenzen und Abhängigkeiten zu verhindern, ist „Domain-driven Design“ (deutsch: domänengetriebenes Design) ein wichtiges Werkzeug. Die Ansätze u.a. das Domänenwissen der Abteilung/ Branchen, „Ubiquitous Language“ und „Bounded Context“ sind für das Konzeptionieren von Nöten.</description></item><item><title>Standards und Entscheidungen</title><link>/webhandbook/microservices/_5_standards_und_entscheidungen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/webhandbook/microservices/_5_standards_und_entscheidungen/</guid><description>Technologie-Entscheidung Aufgrund der Microservice-Architektur sind die Entwickler nicht eingeschränkt, eine und dieselbe Technologiebasis zu nutzen. Jedes Team einer einzelnen Microservice kann eigenständig entscheiden welche Programmiersprache, Tools, Frameworks und Datenbanksystem sie verwenden wollen. Der wichtigste Faktor für die Auswahl ist die Expertise des Teams. Neben der Expertise ist die Unterstützung der gewünschten Programmierumgebung bei einem Anbieter (Serveranbieter, Cloud-Provider) wichtig.
Prinzipien und Standards Beim Entwickeln von Services ist für die Programmierer wichtig, dass sie einen Leitfaden befolgen.</description></item></channel></rss>